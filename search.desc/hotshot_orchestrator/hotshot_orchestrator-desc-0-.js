searchState.loadedDescShard("hotshot_orchestrator", 0, "Orchestrator for manipulating nodes and recording results …\nOrchestrator is not, strictly speaking, bound to the …\nOrchestrator Version (minor)\nOrchestrator Version as a type-binding instance\nAn api exposed by the orchestrator\nThe state of the orchestrator\nOrchestrator Version as a type\nWhether we are still accepting new keys for registration\nThe results of the benchmarks\nBuilder address pool\nThe orchestrator’s clients\nThe network configuration\nSets up all API routes\nwhether we are using a fixed stake table, disabling public …\nReturns the argument unchanged.\nget endpoints for builders\nget endpoint for whether or not the run has started\nget endpoint for the next available temporary node index\nCalls <code>U::from(self)</code>.\nTracks the latest node index we have generated a …\nGenerate an keypair based on a <code>seed</code> and an <code>index</code>\nWhether the orchestrator can be started manually\ncreate a new <code>OrchestratorState</code>\nThe total nodes that have posted they are ready to start\nThe number of nodes that have posted their results\nOutput the results to a csv file according to orchestrator …\npost endpoint for whether or not all peers public keys are …\nWhether the network configuration has been updated with …\npost endpoint for registering a builder with the …\nget endpoint for the network config after all peers public …\npost endpoint for each node’s config\nPost an identity to the orchestrator. Takes in optional …\nPost an identity to the orchestrator. Takes in optional …\npost endpoint for manually starting the orchestrator\nManually start the network\nA node POSTs its public key to let the orchestrator know …\npost endpoint for the results of the run\nA map from public keys to <code>(node_index, is_da)</code>.\nregister a node on the fixed stake table, which was loaded …\npost endpoint for each node’s public key\nregister a node with an unknown public key. this method …\nRuns the orchestrator\nWhether nodes should start their HotShot instances Will be …\nTracks the latest temporary index we have generated for …\nStruct describing a benchmark result\nStruct describing a benchmark result needed for download, …\narguments to run multiple validators\nHolds the client connection to the orchestrator\nArguments passed to the validator\nThe optional advertise address to use for Libp2p\nThe optional advertise address to use for Libp2p\nThe average latency of the transactions\nThe average latency of the transactions\nOptional address to run builder on. Address must be …\nthe client\nThe commit this benchmark was run on\nThe membership committee type used\nThe membership committee type used\nThe size of the da committee\nThe number of failed views during benchmarking\nThe number of failed views during benchmarking\nThe number of fixed_leader_for_gpuvid when we enable the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs <code>ValidatorArgs</code> from <code>MultiValidatorArgs</code> and a …\nRequests a builder URL from orchestrator\nAsynchronously retrieves a <code>NetworkConfig</code> from an …\nRequests the configuration from the orchestrator with the …\nGet the config from the orchestrator. If the identity is …\nPost to the orchestrator and get the latest <code>node_index</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum latency of the transactions\nThe maximum latency of the transactions\nThe minimum latency of the transactions\nThe minimum latency of the transactions\nAn optional network config file to save to/load from …\nAn optional network config file to save to/load from …\nCreates the client that will connect to the orchestrator\nThe number of transactions that were latency measured\nNumber of validators to run\nWhether it’s partial collected results\nWhether the results are partially collected “One” when …\nSends my public key to the orchestrator so that it can …\nSends the benchmark metrics to the orchestrator\nRegisters a builder URL with the orchestrator\nprintout the results of one example run\nThe number of rounds\nThe throughput of the consensus protocol = number of …\nThe throughput of the consensus protocol = number of …\nTotal number of nodes\nThe total number of views during benchmarking\nThe total number of views during benchmarking\nThe total time elapsed for benchmarking\nThe total time elapsed for benchmarking\nThe number of transactions committed during benchmarking\nThe number of transactions committed during benchmarking\nThe size of each transaction in bytes\nThe size of each transaction in bytes\nNumber of transactions submitted per round\nThe address the orchestrator runs on\nThe address the orchestrator runs on\nTells the orchestrator this validator is ready to start …\nGeneric function that waits for the orchestrator to return …")